<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.3.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
</head>
<body>

<script>
var data_right = {"name": "ROOT", "layer": "0", "current": "true", "children": [
    {"name": "A-child", "warning": "true", "layer": "1", "children": [
            {"name": "WHAT THE FUCK", "layer": "2"},
            {"name": "A2kusi", "warning": "true","layer": "2", "children": [
                    {"name": "A21", "warning": "true", "layer": "3"},
                    {"name": "A2Dshhhhhhhd", "layer": "3", "children": [
                            {"name": "A221", "layer": "4"},
                            {"name": "A224", "layer": "4"},
                            {"name": "ffjjjjjj", "layer": "4"},
                            {"name": "hHHsddd", "layer": "4"},
                            {"name": "A225", "layer": "4"}
                        ]}
                ]}
        ]},
        {"name": "BBBBBBBBB", "layer": "1", "children": [
                            {"name": "JJJJJJ", "layer": "4"},
                            {"name": "AAAA", "layer": "4", "children": [
                            {"name": "A221", "layer": "4"},
                            {"name": "A224", "layer": "4"},
                            {"name": "A225", "layer": "4"}
                        ]},
                            {"name": "NNNNNNNNNNNkkkkkkkkk", "layer": "4"}
                        ]},
    {"name": "Cggd", "layer": "1", "children": [
            {"name": "C1", "layer": "2"},
            {"name": "C2", "layer": "2", "children": [
                    {"name": "C21", "layer": "3"},
                    {"name": "C22", "layer": "3"}
                ]}
        ]}
]};

var data_left = {"name": "", "layer": "0", "current": "true", "children": [
    {"name": "A-child", "warning": "true", "layer": "1", "children": [
            {"name": "WHAT THE FUCK", "layer": "2"},
            {"name": "A2kusi", "warning": "true","layer": "2", "children": [
                    {"name": "A21", "warning": "true", "layer": "3"},
                    {"name": "A2Dshhhhhhhd", "layer": "3", "children": [
                            {"name": "A221", "layer": "4"},
                            {"name": "A224", "layer": "4"},
                            {"name": "A225", "layer": "4"}
                        ]}
                ]}
        ]},
    {"name": "BBBBBBBBB", "layer": "1", "children": [
                            {"name": "JJJJJJ", "layer": "4"},
                            {"name": "AAAA", "layer": "4", "children": [
                            {"name": "A221", "layer": "4"},
                            {"name": "A224", "layer": "4"},
                            {"name": "A225", "layer": "4"}
                        ]},
                            {"name": "NNNNNNNNNNNkkkkkkkkk", "layer": "4"}
                        ]},
    {"name": "Cggd", "layer": "1", "children": [
            {"name": "C1", "layer": "2"},
            {"name": "C2", "layer": "2", "children": [
                    {"name": "C21", "layer": "3"},
                    {"name": "C22", "layer": "3"}
                ]}
        ]}
]};


var padding =50;
var stroke = "#555"
var strokeWidth = 1.5
var strokeOpacity = 0.4
var halo = "#fff"
var haloWidth = 3
var fill = "#999"
var r = 3
var width = 1000
var height = 1000

        var root_right = d3.hierarchy(data_right);

        const dx = 100;
        const dy = width / (root_right.height + 50);
        //d3.tree().size([500, -500])(root);
        d3.tree().nodeSize([20, 80])(root_right);

        var root_left = d3.hierarchy(data_left);
        d3.tree().nodeSize([20, -80])(root_left);

        var ii = 0
        function position_iter(items) {
                items.map(item => {
                if (item.parent !== null) {
                        var x_array = item.parent.children.map(x=>x.x)
                        var mid_position = (Math.min(...x_array) + Math.max(...x_array))/2
                        item.parent.x = mid_position
                }
                })
                var t = items.map(x=>x.parent).filter(n=>n)
                if (t.length > 0) position_iter(t)        
        }
        
        // initialize leaves positions
        root_right.leaves().map((item, i) => {
        item.x = -100 + i * 15
        })
        // recursive start
        position_iter(root_right.leaves())




//   d3.select("body").append("svg").attr("style", "background-color:blue").attr("width",100)
//                 .attr("height", 100)
//                 .attr("transform", d => `translate(200, 200)`)


d3.select("body").append("svg")

        
        drawTree(root_left, "left")
        drawTree(root_right, "right")

  function drawTree(root, side) {
        
        var SIDE_CONST = side === "right" ? 1 : -1
        var SIDE_CONST_TEXT_ANCHOR = side === "right" ? "start" : "end"
        var NODE_CLASS = "node_" + side
        
        const labels = root.descendants().map(d => d.data.name);

        const svg = d3.select("svg")//.append("svg")
        .attr("viewBox", [-500, -500, 1000, 1000])
                .attr("width", 1000)
                .attr("height", 1000)
                .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
                .attr("font-family", "sans-serif")
                .attr("font-size", 10);

        // append nodes

        console.log(root.descendants())
        const node = svg.append("g").attr("class", "node_container")
                .selectAll("." + NODE_CLASS)
                .data(root.descendants())
                .join("a")
                .attr('class', NODE_CLASS)
                // .attr("transform", d => `translate(${d.y},${d.x})`)

        // Add text to nodes.
        var l = node.append("text")
                .attr("dy", "-0.2em")
                .attr("dx", "0.5em")
                .attr("x", d => d.children ? -6 : 6)
                .attr("text-anchor", d => SIDE_CONST_TEXT_ANCHOR)
                .text((d, i) => labels[i])
                // .call(text => text.clone(true))
                // // .attr("fill", "none")
                // .attr("stroke", halo)
                // .attr("stroke-width", haloWidth);

        // compute text length.
        var text_length = l.nodes().reduce((prev, cur) => ({...prev, [cur.__data__.data.name]: cur.getComputedTextLength() || 0}), {})

        // set position y_start and y_end of each node.
        root.descendants().map(item => {
                item.y_start = item.y
                item.y_end = item.y + SIDE_CONST * text_length[item.data.name]
                item.abs_length = Math.abs(text_length[item.data.name])
        })

        // if one single node is changing its length, there is a need to update all the childs node position,
        // this is what this .map is doing.
        root.descendants().map(x => {
                if (x.children) {
                        if (side === 'right')
                        x.children.map(child => {
                                child.y_start = child.y_start + x.abs_length
                                child.y_end = child.y_end + x.abs_length
                        })

                        if (side === 'left')
                        x.children.map(child => {
                                child.y_start = child.y_start - x.abs_length
                                child.y_end = child.y_end - x.abs_length
                        })
        }
        })

        // shift text to updated positions.
        svg.selectAll("." + NODE_CLASS)
        .data(root.descendants())
        .join(enter => enter.append("circle"),
                update => 
                update.attr("transform", d => `translate(${d.y_start},${d.x})`)
        )
        
        // internode links with updated positions
        svg.append("g").attr("class", "link_container")
                .attr("fill", "none")
                .attr("stroke", stroke)
                .attr("stroke-opacity", strokeOpacity)
                .attr("stroke-linecap", null)
                .attr("stroke-linejoin", null)
                .attr("stroke-width", strokeWidth)
                .selectAll(".link")
                .data(root.links())
                .join("path")
                .attr("class", "link")
                .attr("d", d3.linkHorizontal()
                .source(d => ({...d.source, 'type': 'source'}))
                .target(d => ({...d.target, 'type': 'target'}))
                .x(d => d.type === 'source'? d.y_end:d.y_start)
                .y(d => d.x));

        //underlined text paths
        var text_underlined_path = root.descendants().map(x=>([[x.y_end,x.x], [x.y_start, x.x]]))

        svg.append("g").attr("class", "underlined_path_container")
        .attr("stroke", stroke)
        .attr("stroke-opacity", strokeOpacity)
        .attr("stroke-width", strokeWidth)
        .selectAll(".link")
                .data(text_underlined_path)
                .join("path").attr("class", "link")
                .attr("d", d3.line());

      var chart = svg.node();

  }




      let zoom = d3.zoom()
	.on('zoom', handleZoom);

function handleZoom(e) {
	d3.select('svg')
        .selectAll('g')
		.attr('transform', e.transform);
}

d3.select('svg')
  .call(zoom);


//       console.log("root.descendants()")
//         console.log(root.descendants())

// const zip = (a, b) => a.map((k, i) => [k, b[i]]);
// var ba = l.nodes().map(node => ({"id": node.__data__.data.name, "length": node.getComputedTextLength()}))
// var ba3 = l.nodes().reduce((prev, cur, i) => ({...prev, [i]: cur.getComputedTextLength() || 0}), {})
// var ttt = l.nodes().map(node => ({[node.__data__.data.name]: node.getComputedTextLength()}))
// var t = root.links().map(link=> ({"id": link.source.data.name}))
// var b = l.nodes().map(node => node.getComputedTextLength())

</script>
</body>
</html>